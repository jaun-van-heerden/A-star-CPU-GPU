from PIL import Image
import numpy as np

image_path = 'ferrari.jpg'
image = Image.open(image_path)
image_array = np.array(image)  # Shape: (height, width, 3)


from typing import List, Tuple, Dict, Union
import heapq

# def heuristic(node: Tuple[int, int], end: Tuple[int, int]) -> int:
#     return abs(node[0] - end[0]) + abs(node[1] - end[1])

def heuristic(node, end):
    return np.linalg.norm(image_array[node] - image_array[end])


def is_valid_move(neighbor: Tuple[int, int], matrix: List[List[int]]) -> bool:
    return 0 <= neighbor[0] < len(matrix) and 0 <= neighbor[1] < len(matrix[0]) and matrix[neighbor[0]][neighbor[1]] != 1

def reconstruct_path(came_from: Dict[Tuple[int, int], Tuple[int, int]], current_node: Tuple[int, int]) -> List[Tuple[int, int]]:
    path = []
    while current_node in came_from:
        path.insert(0, current_node)
        current_node = came_from[current_node]
    return path

# def astar(matrix: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> Union[List[Tuple[int, int]], None]:
#     moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]
#     open_list = [(0, start)]
#     came_from = {}
#     g_score = {(i, j): float('inf') for i in range(len(matrix)) for j in range(len(matrix[0]))}
#     g_score[start] = 0

#     while open_list:
#         _, current_node = heapq.heappop(open_list)

#         if current_node == end:
#             return reconstruct_path(came_from, current_node)

#         for move in moves:
#             neighbor = (current_node[0] + move[0], current_node[1] + move[1])
            
#             if is_valid_move(neighbor, matrix):
#                 tentative_g_score = g_score[current_node] + 1

#                 if tentative_g_score < g_score[neighbor]:
#                     came_from[neighbor] = current_node
#                     g_score[neighbor] = tentative_g_score
#                     f_score = tentative_g_score + heuristic(neighbor, end)
#                     heapq.heappush(open_list, (f_score, neighbor))

#     return None



def astar(image_array, start, end):
    def cost(current, neighbor):
        return np.sum(np.abs(image_array[current] - image_array[neighbor]))
    
    moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    open_list = [(0, start)]
    came_from = {}
    g_score = {node: float('inf') for node in np.ndindex(image_array.shape[:2])}
    g_score[start] = 0

    while open_list:
        current_cost, current_node = heapq.heappop(open_list)
        
        if current_node == end:
            # Reconstruct the path
            path = []
            while current_node in came_from:
                path.insert(0, current_node)
                current_node = came_from[current_node]
            return path

        for move in moves:
            neighbor = tuple(map(sum, zip(current_node, move)))
            if 0 <= neighbor[0] < image_array.shape[0] and 0 <= neighbor[1] < image_array.shape[1]:
                tentative_g_score = g_score[current_node] + cost(current_node, neighbor)

                if tentative_g_score < g_score[neighbor]:
                    came_from[neighbor] = current_node
                    g_score[neighbor] = tentative_g_score
                    f_score = tentative_g_score + heuristic(neighbor, end)
                    heapq.heappush(open_list, (f_score, neighbor))

    return None


# Example usage
if __name__ == "__main__":
    # matrix = [
    #     [0, 1, 0, 0, 0],
    #     [0, 1, 0, 1, 0],
    #     [0, 0, 0, 1, 0],
    #     [0, 1, 0, 0, 0],
    #     [0, 0, 0, 0, 0]
    # ]
    # start = (0, 0)
    # end = (4, 4)
    # shortest_path = astar(matrix, start, end)
    # print(shortest_path)


    start = (0, 0)
    end = (image_array.shape[0] - 1, image_array.shape[1] - 1)
    shortest_path = astar(image_array, start, end)





import cv2
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image

# Your A* algorithm here (as defined in the previous step)

def draw_path_on_image(image_array, path, color):
    for point in path:
        cv2.circle(image_array, (point[1], point[0]), 1, color, -1)

if __name__ == "__main__":
    image_path = 'path/to/your/image.png'
    image = Image.open(image_path)
    image_array = np.array(image)

    start = (0, 0)
    end = (image_array.shape[0] - 1, image_array.shape[1] - 1)

    # Find the shortest paths for R, G, and B
    shortest_path_R = astar(image_array[:,:,0], start, end)
    shortest_path_G = astar(image_array[:,:,1], start, end)
    shortest_path_B = astar(image_array[:,:,2], start, end)

    # Draw the paths on the image
    draw_path_on_image(image_array, shortest_path_R, [255, 0, 0])  # Red
    draw_path_on_image(image_array, shortest_path_G, [0, 255, 0])  # Green
    draw_path_on_image(image_array, shortest_path_B, [0, 0, 255])  # Blue

    # Display the image with the paths
    plt.imshow(cv2.cvtColor(image_array, cv2.COLOR_BGR2RGB))
    plt.title('Image with R, G, B Paths')
    plt.show()



# import plotly.graph_objects as go

# def visualize_with_plotly(matrix, start, end, path):
#     fig = go.Figure()
    
#     for i, row in enumerate(matrix):
#         for j, value in enumerate(row):
#             color = "white"
#             if (i, j) == start:
#                 color = "green"
#             elif (i, j) == end:
#                 color = "red"
#             elif value == 1:
#                 color = "black"
#             elif (i, j) in path:
#                 color = "blue"
                
#             fig.add_shape(
#                 go.layout.Shape(
#                     type="rect",
#                     x0=j, 
#                     x1=j+1,
#                     y0=i, 
#                     y1=i+1,
#                     fillcolor=color,
#                     line=dict(color=color)
#                 )
#             )
    
#     fig.update_layout(
#         xaxis=dict(range=[0, len(matrix[0])], autorange=False),
#         yaxis=dict(range=[0, len(matrix)], autorange=False, scaleanchor="x"),
#         width=600,
#         height=600,
#         autosize=False
#     )
    
#     fig.show()

# # Assuming `shortest_path` and `matrix` are available from the previous A* algorithm.
# if shortest_path:
#     visualize_with_plotly(matrix, start, end, shortest_path)


